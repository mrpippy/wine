#!/usr/bin/env python3
# Wine syscall mapping function generator
#
# Copyright 2020 Brendan Shanks for CodeWeavers
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
#

import os
import re
import urllib.request
import json

COMMIT = "422c94e45479342cb3938cdcaa1bd966bb13f991"

# Map Windows versions used in the JSON file to major/minor/build
VERSION_MAPPING = {
    ("Windows Vista", "SP0"): (6,0,6000),
    ("Windows Vista", "SP1"): (6,0,6001),
    ("Windows Vista", "SP2"): (6,0,6002),
    ("Windows 7", "SP0")    : (6,1,7600),
    ("Windows 7", "SP1")    : (6,1,7601),
    ("Windows 8", "8.0")    : (6,2,9200),
    ("Windows 8", "8.1")    : (6,3,9600),
    ("Windows 10", "1507")  : (10,0,10240),
    ("Windows 10", "1511")  : (10,0,10586),
    ("Windows 10", "1607")  : (10,0,14393),
    ("Windows 10", "1703")  : (10,0,15063),
    ("Windows 10", "1709")  : (10,0,16299),
    ("Windows 10", "1803")  : (10,0,17134),
    ("Windows 10", "1809")  : (10,0,17763),
    ("Windows 10", "1903")  : (10,0,18362),
    ("Windows 10", "1909")  : (10,0,18363),
    ("Windows 10", "2004")  : (10,0,19041),
}

IGNORE_VERSIONS = [
    "Windows XP",
    "Windows Server 2003",
    "Windows Server 2008",
    "Windows Server 2012",
]

NTDLL_SPEC = "../ntdll.spec"
SYSCALLS_C = "syscalls.c"

tables = { }

winesyscalls = set()

def populate_winesyscalls():
    with open(NTDLL_SPEC, "r") as f:
        regex = re.compile("^@.* (Nt.*)\(")
        for line in f:
            match = regex.match(line) 
            if match:
                winesyscalls.add(match.group(1))


def generate_syscalls_c(f):
    f.write("/*\n")
    f.write(" * Automatically generated by make_syscall_tables. DO NOT EDIT!\n")
    f.write(" *\n")
    f.write(" * Windows to Wine NT syscall number mappings\n")
    f.write(" *\n")
    f.write(" * Copyright 2020 Brendan Shanks for CodeWeavers\n")
    f.write(" *\n")
    f.write(" * This library is free software; you can redistribute it and/or\n")
    f.write(" * modify it under the terms of the GNU Lesser General Public\n")
    f.write(" * License as published by the Free Software Foundation; either\n")
    f.write(" * version 2.1 of the License, or (at your option) any later version.\n")
    f.write(" *\n")
    f.write(" * This library is distributed in the hope that it will be useful,\n")
    f.write(" * but WITHOUT ANY WARRANTY; without even the implied warranty of\n")
    f.write(" * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n")
    f.write(" * Lesser General Public License for more details.\n")
    f.write(" *\n")
    f.write(" * You should have received a copy of the GNU Lesser General Public\n")
    f.write(" * License along with this library; if not, write to the Free Software\n")
    f.write(" * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n")
    f.write(" */\n\n")

    f.write("#if 0\n")
    f.write("#pragma makedep unix\n")
    f.write("#endif\n\n")

    f.write("#ifdef __x86_64__\n\n")

    f.write("#include \"config.h\"\n")
    f.write("#include \"wine/port.h\"\n\n")

    f.write("#include <pthread.h>\n\n")
    f.write("#include <stdarg.h>\n\n")

    f.write("#include \"ntstatus.h\"\n")
    f.write("#define WIN32_NO_STATUS\n")
    f.write("#define NONAMELESSUNION\n")
    f.write("#include \"windef.h\"\n")
    f.write("#include \"winternl.h\"\n")
    f.write("#include \"unix_private.h\"\n")
    f.write("#include \"wine/debug.h\"\n\n")

    f.write("WINE_DEFAULT_DEBUG_CHANNEL(seh);\n\n")

    f.write("static pthread_once_t check_version_once = PTHREAD_ONCE_INIT;\n")
    f.write("static unsigned int (*map_function)(unsigned int);\n\n")

    f.write("#define INVALID_SYSCALL 0x0fff\n\n")

    for syscall in sorted(winesyscalls):
        f.write("extern unsigned int __wine_syscall_nr_{0};\n".format(syscall))

    f.write("\n")

    for table in tables:
        f.write("static unsigned int win{0}_{1}_{2}(unsigned int ntsyscall)\n".format(table[0],table[1],table[2]))
        f.write("{\n")
        f.write("    switch(ntsyscall)\n")
        f.write("    {\n")
        for syscall in tables[table]:
            if syscall in winesyscalls:
                f.write("        case {0}: return __wine_syscall_nr_{1};\n".format(hex(tables[table][syscall]), syscall))
        f.write("        default: return INVALID_SYSCALL;\n")
        f.write("    }\n")
        f.write("}\n\n")

    f.write("static unsigned int unknown_version(unsigned int ntsyscall)\n".format(table[0],table[1],table[2]))
    f.write("{\n")
    f.write("    return INVALID_SYSCALL;\n")
    f.write("}\n\n")

    f.write("\n")
    f.write("struct version\n")
    f.write("{\n")
    f.write("    DWORD major;\n")
    f.write("    DWORD minor;\n")
    f.write("    DWORD build;\n")
    f.write("    unsigned int (*map_function)(unsigned int);\n")
    f.write("} versions[] = {\n")
    for table in tables:
        f.write("    {{{0},{1},{2},win{0}_{1}_{2}}},\n".format(table[0],table[1],table[2]))
    f.write("};\n\n")

    f.write("static void determine_version(void)\n")
    f.write("{\n")
    f.write("    unsigned int i;\n")
    f.write("    RTL_OSVERSIONINFOEXW info;\n\n")

    f.write("    RtlGetVersion(&info);\n")

    f.write("    for (i = 0; i < ARRAY_SIZE(versions); i++)\n")
    f.write("    {\n")
    f.write("        if ((info.dwMajorVersion == versions[i].major) &&\n")
    f.write("            (info.dwMinorVersion == versions[i].minor) &&\n")
    f.write("            (info.dwBuildNumber == versions[i].build))\n")
    f.write("        {\n")
    f.write("            map_function = versions[i].map_function;\n")
    f.write("            return;\n")
    f.write("        }\n")
    f.write("    }\n\n")

    f.write("    FIXME(\"No NT syscall mapping table for version %d.%d.%d\",\n")
    f.write("          info.dwMajorVersion, info.dwMinorVersion, info.dwBuildNumber);\n")
    f.write("    map_function = unknown_version;\n")
    f.write("}\n\n")

    f.write("unsigned int __wine_syscall_nr_from_nt(unsigned int ntsyscall)\n")
    f.write("{\n")
    f.write("    unsigned int ret;\n\n")
    f.write("    pthread_once(&check_version_once, determine_version);\n\n")
    f.write("    ret = map_function(ntsyscall);\n")
    f.write("    if (ret == INVALID_SYSCALL)\n")
    f.write("        FIXME(\"Unknown NT syscall number %u\\n\", ntsyscall);\n\n")
    f.write("    return ret;\n")
    f.write("}\n\n")

    f.write("#endif  /* __x86_64__ */\n")



def set_working_directory():
    path = os.path.abspath(__file__)
    path = os.path.dirname(path)
    os.chdir(path)

def download_json(filename, architecture):
    url = "https://raw.githubusercontent.com/j00ru/windows-syscalls/{0}/{1}/json/nt-per-system.json".format(COMMIT, architecture)
    if not os.path.isfile(filename):
        urllib.request.urlretrieve(url, filename)

def main():
    set_working_directory()

    x64_json_filename = "nt-syscalls-x64-{0}.json".format(COMMIT[:8])
    download_json(x64_json_filename, "x64")

    x64 = json.load(open(x64_json_filename, 'r'))

    for major in x64:
        if major in IGNORE_VERSIONS:
            continue

        for minor in x64[major]:
            if not (major,minor) in VERSION_MAPPING:
                print("Major/minor/build numbers missing for",major,minor)
                continue

            #print(major,minor)
            tables[VERSION_MAPPING[(major,minor)]] = x64[major][minor]
            #print(tables)

    # Filter syscallnames based on syscalls present in Wine
    populate_winesyscalls()

    # Generate file
    with open(SYSCALLS_C, "w") as f:
        generate_syscalls_c(f)

if __name__ == "__main__":
    main()
